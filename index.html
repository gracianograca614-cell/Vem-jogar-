<!doctype html>
<html lang="pt">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Meu Cassino — BacBo Robot (Automático + Imagem)</title>

<!-- Three.js (CDN) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r148/three.min.js"></script>

<style>
:root{
  --bg:#071428; --card:#0b1220; --muted:#9fb0c8; --accent:#7c3aed;
  --banca:#e74c3c; --player:#3498db; --empate:#f2c94c; --glass: rgba(255,255,255,0.03);
  --text:#eaf2ff;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#041025);color:var(--text);font-family:Inter,Arial,Helvetica,sans-serif;-webkit-font-smoothing:antialiased}
.container{max-width:1100px;margin:0 auto;padding:14px}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
.brand{font-weight:900;font-size:1.25rem;letter-spacing:0.4px}
.small{color:var(--muted);font-size:0.92rem}
.panel{background:var(--card);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.02);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
.grid{display:grid;grid-template-columns:1fr 360px;gap:14px}
@media(max-width:980px){.grid{grid-template-columns:1fr}}
.scene-wrap{height:420px;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,#071428,#031420)}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:10px}
.button{background:var(--accent);border:0;padding:10px 12px;border-radius:10px;color:#fff;font-weight:700;cursor:pointer}
.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
.file{padding:8px;border-radius:8px;border:1px dashed rgba(255,255,255,0.06);background:transparent;color:var(--text)}
.info-row{display:flex;align-items:center;gap:8px;justify-content:space-between}
.sinal{display:flex;align-items:center;gap:12px;padding:12px;border-radius:10px;margin-top:8px;font-weight:800;justify-content:center}
.dot{width:18px;height:18px;border-radius:6px}
.pred-list{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
.pred-pill{padding:8px 12px;border-radius:10px;font-weight:800;color:#000}
.history{max-height:360px;overflow:auto;margin-top:12px;border-radius:8px;padding:8px;background:var(--glass)}
.hist-row{display:flex;justify-content:space-between;padding:8px;border-bottom:1px dashed rgba(255,255,255,0.03);align-items:center}
.login-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(2,6,23,0.7), rgba(2,6,23,0.85));z-index:9999}
.login-card{background:linear-gradient(180deg,#081426,#071428);padding:18px;border-radius:12px;width:95%;max-width:420px;border:1px solid rgba(255,255,255,0.04)}
.login-card input{width:100%;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text)}
.login-card button{margin-top:10px;width:100%}
.footer{margin-top:12px;text-align:center;color:var(--muted);font-size:0.85rem}
.badge{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-weight:700}

</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div>
      <div class="brand">Meu Cassino — BacBo Robot</div>
      <div class="small">Simulador · Upload de print-shot → detecção automática → previsão</div>
    </div>
    <div class="small">Sessão: <span id="sessionName" class="badge">—</span></div>
  </div>

  <div class="grid">
    <!-- Left: Scene + controls -->
    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div><strong>Mesa ao vivo</strong><div class="small">3D · Mesa rotativa · chips</div></div>
          <div class="small">Intervalo auto: <span id="intervalLabel">6s</span></div>
        </div>

        <div id="sceneContainer" class="scene-wrap" style="margin-top:12px;"></div>

        <div class="controls">
          <label class="file small">Imagem: <input id="imgInput" type="file" accept="image/*" style="display:inline-block;margin-left:8px"/></label>
          <button id="btnAutoSim" class="button ghost">Auto-Sim (Desligado)</button>
          <input id="seedInput" placeholder="seed (opcional)" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)" />
          <button id="btnClear" class="button ghost">Limpar</button>
          <button id="btnExport" class="button ghost">Exportar</button>
        </div>

        <div class="sinal panel" style="margin-top:12px;justify-content:space-between">
          <div style="display:flex;gap:12px;align-items:center">
            <div class="dot" id="mainDot" style="background:#888"></div>
            <div id="mainSignalText">Sinal: —</div>
          </div>
          <div class="small">Última análise: <span id="lastAnalys">—</span></div>
        </div>

        <div class="panel" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Previsões (2–3 próximas)</strong></div>
            <div class="small">Algoritmo: <span id="algoName">Mulberry32</span></div>
          </div>
          <div id="predictions" class="pred-list"></div>
        </div>
      </div>
    </div>

    <!-- Right: History + stats -->
    <div>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div><strong>Histórico</strong><div class="small">Detecções (últimas 50)</div></div>
          <div><button id="btnGenManual" class="button">Gerar Prev (manual)</button></div>
        </div>

        <div class="history" id="historyBox" style="margin-top:12px"></div>

        <div style="margin-top:12px" class="small">Estatísticas</div>
        <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
          <div class="badge">Rodadas: <span id="statRounds">0</span></div>
          <div class="badge">Coincidências: <span id="statMatch">0</span></div>
        </div>

        <div style="margin-top:12px" class="small">Tempo local: <span id="localTime">--:--:--</span></div>
      </div>
    </div>
  </div>

  <div class="footer">© Meu Cassino — uso apenas para treino · Não garante ganhos reais</div>
</div>

<!-- Login overlay -->
<div id="loginOverlay" class="login-overlay" style="display:none">
  <div class="login-card panel">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div>
        <div style="font-weight:900;font-size:18px">Entrar na sessão</div>
        <div class="small">Insira seu nome para começar</div>
      </div>
    </div>
    <input id="loginName" placeholder="Ex: Graciano" />
    <button id="loginBtn" class="button">Entrar</button>
  </div>
</div>

<script>
/* ---------- Utilities ---------- */
function $(id){return document.getElementById(id)}
function nowTime(){ const d=new Date(); return d.toLocaleTimeString(); }
setInterval(()=>{$('localTime').innerText = nowTime();},1000);

/* ---------- PRNG mulberry32 ---------- */
function mulberry32(a){ return function(){ a |= 0; a = a + 0x6D2B79F5 | 0; var t = Math.imul(a ^ a >>> 15, 1 | a); t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }

/* ---------- RGB -> HSV ---------- */
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h=0, s=0, v=max;
  const d=max-min;
  s = max===0 ? 0 : d/max;
  if(max===min) h=0;
  else {
    switch(max){
      case r: h = (g-b)/d + (g<b?6:0); break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h /= 6;
  }
  return {h:Math.round(h*360), s:Math.round(s*100), v:Math.round(v*100)};
}

/* ---------- Map HSV -> outcome ---------- */
function mapHsvToOutcome(hsv){
  const h = hsv.h, s = hsv.s, v = hsv.v;
  // thresholds tuned for screenshots: red ~0/360, blue ~210, yellow ~55
  if(s < 10 && v > 90) return {o:null, label:'Indefinido', reason:'muito claro'};
  if((h >= 340 && h <= 360) || (h >= 0 && h <= 25)) return {o:'B', label:'Banca', color: getComputedStyle(document.documentElement).getPropertyValue('--banca')};
  if(h >= 190 && h <= 260) return {o:'P', label:'Player', color: getComputedStyle(document.documentElement).getPropertyValue('--player')};
  if(h >= 30 && h <= 90) return {o:'T', label:'Empate', color: getComputedStyle(document.documentElement).getPropertyValue('--empate')};
  return {o:null, label:'Indefinido', reason:`h=${h}`};
}

/* ---------- App State ---------- */
let state = {
  rounds: [], // newest first, values: 'B','P','T'
  seed: null,
  prng: Math.random,
  roundsCount: 0,
  matches: 0,
  autoSim: false,
  autoTimer: null,
  autoInterval: 6
};

/* ---------- UI refs ---------- */
const imgInput = $('imgInput'), btnAutoSim = $('btnAutoSim'), btnClear = $('btnClear'), btnExport = $('btnExport'), btnGenManual = $('btnGenManual');
const predictionsBox = $('predictions'), mainDot = $('mainDot'), mainSignalText = $('mainSignalText');
const historyBox = $('historyBox'), statRounds = $('statRounds'), statMatch = $('statMatch'), lastAnalys = $('lastAnalys'), intervalLabel = $('intervalLabel');
const seedInput = $('seedInput'), algoName = $('algoName');

/* ---------- Session handling ---------- */
function showLoginIfNeeded(){
  const name = localStorage.getItem('mc_name');
  if(!name){ $('loginOverlay').style.display='flex'; } else { $('sessionName').innerText = name; $('loginOverlay').style.display='none'; }
}
$('loginBtn').addEventListener('click', ()=>{
  const v = $('loginName').value.trim()||'Player';
  localStorage.setItem('mc_name', v);
  $('sessionName').innerText = v;
  $('loginOverlay').style.display='none';
});
showLoginIfNeeded();

/* ---------- Three.js scene (professional-ish) ---------- */
let scene, camera, renderer, tableMesh, chipMesh;
function initScene(){
  const container = $('sceneContainer');
  const W = container.clientWidth, H = container.clientHeight || 420;
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, W/H, 0.1, 2000);
  camera.position.set(0,120,240);
  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio||1);
  renderer.setSize(W, H);
  container.appendChild(renderer.domElement);

  // lights
  const amb = new THREE.AmbientLight(0xffffff,0.25); scene.add(amb);
  const spot = new THREE.SpotLight(0xffffff,1.0); spot.position.set(0,300,120); scene.add(spot);
  const rim = new THREE.PointLight(0x7c3aed,0.2); rim.position.set(-200,80,120); scene.add(rim);

  // floor (subtle)
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(1200,1200), new THREE.MeshStandardMaterial({color:0x05080a, metalness:0.1, roughness:0.9}));
  floor.rotation.x = -Math.PI/2; floor.position.y=-60; scene.add(floor);

  // table
  const loader = new THREE.TextureLoader();
  loader.load('https://i.imgur.com/2QfG7lF.jpg', function(tex){
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(2,2);
    const geo = new THREE.CylinderGeometry(120,120,16,64);
    const mat = new THREE.MeshStandardMaterial({map:tex, metalness:0.15, roughness:0.6});
    tableMesh = new THREE.Mesh(geo, mat);
    tableMesh.rotation.x = Math.PI/2;
    tableMesh.position.y = 0;
    scene.add(tableMesh);
  }, undefined, ()=> {
    // fallback: plain color
    const geo = new THREE.CylinderGeometry(120,120,16,64);
    const mat = new THREE.MeshStandardMaterial({color:0x052f3b, metalness:0.15, roughness:0.6});
    tableMesh = new THREE.Mesh(geo, mat);
    tableMesh.rotation.x = Math.PI/2; scene.add(tableMesh);
  });

  // chip
  const chipGeo = new THREE.TorusGeometry(36,5,16,100);
  const chipMat = new THREE.MeshStandardMaterial({color:0x8f7ae6, metalness:0.6, roughness:0.25});
  chipMesh = new THREE.Mesh(chipGeo, chipMat);
  chipMesh.rotation.x = Math.PI/2; chipMesh.position.y = 8; scene.add(chipMesh);

  function animate(){
    requestAnimationFrame(animate);
    if(tableMesh) tableMesh.rotation.z += 0.002;
    if(chipMesh) chipMesh.rotation.z -= 0.01;
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', ()=> {
    const W2 = container.clientWidth, H2 = container.clientHeight || 420;
    renderer.setSize(W2,H2);
    camera.aspect = W2/H2; camera.updateProjectionMatrix();
  });
}
initScene();

/* ---------- Image analysis: crop central area, sample pixels ---------- */
async function analyzeImageFile(file){
  return new Promise((resolve,reject)=>{
    const reader = new FileReader();
    reader.onload = (ev)=>{
      const img = new Image();
      img.onload = ()=>{
        // scale down if huge
        const MAX = 1000;
        let w = img.width, h = img.height;
        const scale = Math.min(1, MAX / Math.max(w,h));
        w = Math.round(w*scale); h = Math.round(h*scale);

        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img,0,0,w,h);

        // central crop (30% area)
        const cw = Math.max(20, Math.floor(w * 0.32));
        const ch = Math.max(20, Math.floor(h * 0.32));
        const sx = Math.floor((w - cw)/2), sy = Math.floor((h - ch)/2);
        const imgData = ctx.getImageData(sx, sy, cw, ch);
        const data = imgData.data;

        // sample pixels to compute robust average (skip step)
        let rSum=0,gSum=0,bSum=0,count=0;
        const totalPixels = cw*ch;
        const sampleStep = Math.max(1, Math.floor(totalPixels/3000)); // aim ~3k samples
        for(let i=0;i<totalPixels;i+=sampleStep){
          const idx = i*4;
          rSum += data[idx]; gSum += data[idx+1]; bSum += data[idx+2];
          count++;
        }
        const rAvg = Math.round(rSum/count), gAvg=Math.round(gSum/count), bAvg=Math.round(bSum/count);
        const hsv = rgbToHsv(rAvg,gAvg,bAvg);
        const mapped = mapHsvToOutcome(hsv);

        // return debug info + color values
        resolve({r:rAvg,g:gAvg,b:bAvg,hsv,mapped});
      };
      img.onerror = (e)=> reject(e);
      img.src = ev.target.result;
    };
    reader.onerror = (e)=> reject(e);
    reader.readAsDataURL(file);
  });
}

/* ---------- Update UI helpers ---------- */
function setMainSignal(code){
  const el = mainDot;
  const txt = mainSignalText;
  if(code === 'B'){ el.style.background = 'var(--banca)'; txt.innerText = 'Banca'; }
  else if(code === 'P'){ el.style.background = 'var(--player)'; txt.innerText = 'Player'; }
  else if(code === 'T'){ el.style.background = 'var(--empate)'; txt.innerText = 'Empate'; }
  else { el.style.background = '#888'; txt.innerText = '—'; }
}

function renderHistory(){
  const box = historyBox;
  if(state.rounds.length === 0){ box.innerHTML = '<div class="small">Sem rodadas ainda.</div>'; return; }
  box.innerHTML = state.rounds.map((r,i)=>{
    const label = r==='B'?'Banca':r==='P'?'Player':'Empate';
    const color = r==='B'?'var(--banca)':r==='P'?'var(--player)':'var(--empate)';
    return `<div class="hist-row"><div style="font-weight:800;color:${color}">${label}</div><div class="small">${new Date().toLocaleTimeString()}</div></div>`;
  }).join('');
  statRounds.innerText = state.roundsCount;
  statMatch.innerText = state.matches;
}

/* ---------- Prediction engine: generate 2-3 predictions ---------- */
function generatePredictions(){
  const preds = [];
  const rng = state.prng;
  const last = state.rounds[0] || null;
  // Count frequencies in last N
  const N = Math.min(15, state.rounds.length);
  const slice = state.rounds.slice(0,N);
  const counts = {B:0,P:0,T:0};
  slice.forEach(x=>counts[x]++);
  const total = Math.max(1, slice.length);
  // decide first pred: mix momentum + contrarian + random
  let first;
  if(last){
    // momentum probability proportional to recent frequency with slight bias
    const rand = rng();
    if(rand < 0.55) {
      // follow trend (highest freq)
      const leader = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
      first = leader;
    } else {
      // contrarian: choose least frequent
      const least = Object.entries(counts).sort((a,b)=>a[1]-b[1])[0][0];
      first = least;
    }
  } else {
    // random weighted by base probabilities
    const r = rng();
    first = r < 0.48 ? 'B' : (r < 0.96 ? 'P' : 'T');
  }
  preds.push(first);
  // next preds: add small randomness influenced by first
  for(let i=1;i<3;i++){
    const r = rng();
    // if previous is B, slight continuation chance
    const prev = preds[i-1];
    if(prev === 'B') preds.push(r < 0.52 ? 'B' : (r < 0.86 ? 'P' : 'T'));
    else if(prev === 'P') preds.push(r < 0.52 ? 'P' : (r < 0.86 ? 'B' : 'T'));
    else preds.push(r < 0.60 ? 'B' : (r < 0.92 ? 'P' : 'T'));
  }

  // Render predictions
  predictionsBox.innerHTML = '';
  preds.forEach(p=>{
    const el = document.createElement('div');
    el.className = 'pred-pill';
    const label = p==='B'?'Banca':p==='P'?'Player':'Empate';
    const color = p==='B'?'var(--banca)':p==='P'?'var(--player)':'var(--empate)';
    el.style.background = color;
    el.style.color = '#000';
    el.innerText = label;
    predictionsBox.appendChild(el);
  });
  // set main signal first prediction
  setMainSignal(preds[0]);
  return preds;
}

/* ---------- Manage PRNG from seed ---------- */
function initPrngFromSeed(){
  const s = seedInput.value.trim();
  if(s){
    const n = parseInt(s) || (s.split('').reduce((a,c)=>a+c.charCodeAt(0),0) & 0xffffffff);
    state.seed = n;
    state.prng = mulberry32(n);
    algoName.innerText = 'Mulberry32';
  } else {
    state.seed = null;
    state.prng = Math.random;
    algoName.innerText = 'Math.random';
  }
}

/* ---------- Auto simulation (simulates rounds automatically) ---------- */
function startAutoSim(){
  if(state.autoSim) return;
  initPrngFromSeed();
  state.autoSim = true;
  btnAutoSim.innerText = 'Auto-Sim (Ligado)';
  btnAutoSim.classList.remove('ghost');
  const iv = Math.max(1, parseFloat(state.autoInterval) || 6);
  intervalLabel.innerText = iv + 's';
  state.autoTimer = setInterval(()=>{
    // simulate round
    const r = state.prng();
    const code = r < 0.48 ? 'B' : (r < 0.96 ? 'P' : 'T');
    state.rounds.unshift(code);
    if(state.rounds.length>50) state.rounds.pop();
    state.roundsCount++;
    // update history and predictions
    renderHistory();
    generatePredictions();
    lastAnalys.innerText = 'Auto sim @ ' + nowTime();
  }, iv*1000);
}
function stopAutoSim(){
  state.autoSim = false;
  btnAutoSim.innerText = 'Auto-Sim (Desligado)';
  btnAutoSim.classList.add('ghost');
  clearInterval(state.autoTimer);
}

/* ---------- File input handling: auto analyze on change ---------- */
imgInput.addEventListener('change', async (e)=>{
  if(!e.target.files || e.target.files.length === 0) return;
  const file = e.target.files[0];
  try{
    const res = await analyzeImageFile(file);
    lastAnalys.innerText = nowTime();
    // if mapped found, push to rounds automatically
    if(res.mapped && res.mapped.o){
      state.rounds.unshift(res.mapped.o);
      if(state.rounds.length>50) state.rounds.pop();
      state.roundsCount++;
      renderHistory();
      // generate predictions immediately
      initPrngFromSeed();
      generatePredictions();
      // tiny visual feedback
      lastAnalys.innerText += ` · Detected: ${res.mapped.label}`;
      // optional: increment matches if prediction equals detected? not here
    } else {
      lastAnalys.innerText += ' · Indefinido — tenta cortar imagem';
      alert('Detecção indefinida. Tente cortar a screenshot para mostrar apenas a área da cor/rodada e envie novamente.');
    }
  } catch(err){
    console.error(err);
    alert('Erro ao analisar imagem: ' + (err.message || err));
  } finally {
    // reset input so same file can be re-uploaded
    e.target.value = '';
  }
});

/* ---------- Buttons ---------- */
btnAutoSim.addEventListener('click', ()=>{
  if(state.autoSim) stopAutoSim(); else startAutoSim();
});
btnClear.addEventListener('click', ()=>{
  if(!confirm('Apagar histórico?')) return;
  state.rounds = []; state.roundsCount = 0; state.matches = 0;
  renderHistory(); predictionsBox.innerHTML=''; setMainSignal(null); lastAnalys.innerText='—';
});
btnExport.addEventListener('click', ()=>{
  const text = state.rounds.map((r,i)=>`${i+1}|${r}`).join('\n');
  const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'bacbo_log.txt'; a.click(); URL.revokeObjectURL(url);
});
btnGenManual.addEventListener('click', ()=>{ initPrngFromSeed(); generatePredictions(); appendHistory('Manual predict'); });

/* ---------- Small utilities ---------- */
function appendHistory(who){
  // not used heavily: renderHistory shows rounds
  // keep placeholder to show action
  // (optional) add event row
}

/* ---------- Init ---------- */
initPrngFromSeed();
renderHistory();
setMainSignal(null);
$('sessionName').innerText = localStorage.getItem('mc_name') || 'Visitante';
$('loginOverlay').style.display = localStorage.getItem('mc_name') ? 'none' : 'flex';

</script>
</body>
</html>

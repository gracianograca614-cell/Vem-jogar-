# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: '.'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4<!doctype html>
<html lang="pt">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Robô BackBook — Assistente Bac Bo (Graciano)</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --muted:#94a3b8; --accent:#7c3aed;
    --banca:#e74c3c; --jogador:#3498db; --empate:#2ecc71; --glass: rgba(255,255,255,0.04);
    --glass-2: rgba(255,255,255,0.02);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,#071027 0%, #071428 40%, #041023 100%);color:#e6eef6}
  .wrap{max-width:980px;margin:20px auto;padding:18px}
  header{display:flex;align-items:center;gap:12px}
  header h1{font-size:1.3rem;margin:0}
  .subtitle{color:var(--muted);font-size:0.9rem}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:16px;margin-top:16px}
  .card{background:linear-gradient(180deg,var(--card), #071225);border-radius:12px;padding:14px;box-shadow:0 8px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button.btn{background:var(--accent);border:0;color:white;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:600}
  button.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .small{font-size:0.86rem;color:var(--muted)}
  textarea.input{width:100%;height:78px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);padding:10px;background:transparent;color:inherit;font-size:0.95rem;resize:vertical}
  .row{display:flex;gap:8px;align-items:center}
  .clusters{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .badge{padding:8px 10px;border-radius:999px;background:var(--glass);font-weight:700}
  .sinal-card{display:flex;flex-direction:column;align-items:center;gap:8px;padding:14px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:inset 0 -4px 12px rgba(0,0,0,0.4)}
  .sinal-pill{display:flex;align-items:center;gap:12px;padding:10px 14px;border-radius:999px;font-weight:800;font-size:1.15rem}
  .sinal-pill .dot{width:18px;height:18px;border-radius:4px}
  .sinal-detail{font-size:0.95rem;color:var(--muted)}
  .history{max-height:220px;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg,var(--glass-2),transparent);border:1px solid rgba(255,255,255,0.02)}
  .hist-item{display:flex;justify-content:space-between;padding:8px;border-bottom:1px dashed rgba(255,255,255,0.02)}
  .big-prob{font-size:2.6rem;font-weight:800}
  .prob-row{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:10px}
  .prob-card{padding:10px 12px;border-radius:10px;min-width:120px;text-align:center;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border:1px solid rgba(255,255,255,0.02)}
  .muted{color:var(--muted)}
  footer{margin-top:14px;color:var(--muted);font-size:0.85rem;text-align:center}
  /* colors */
  .banca{background:linear-gradient(90deg,var(--banca),#c43a36);border:2px solid rgba(255,255,255,0.03)}
  .jogador{background:linear-gradient(90deg,var(--jogador),#2a79b8);border:2px solid rgba(255,255,255,0.03)}
  .empate{background:linear-gradient(90deg,var(--empate),#27ae60);border:2px solid rgba(255,255,255,0.03)}
  .pulse{animation:pulse 1.2s ease-in-out infinite}
  @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.03)}100%{transform:scale(1)}}
  .confetti{position:relative}
  /* responsive */
  @media (max-width:920px){.grid{grid-template-columns:1fr;}.card{padding:12px}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <svg width="42" height="42" viewBox="0 0 24 24" fill="none" style="border-radius:9px;background:linear-gradient(90deg,#0b1220,#071a2b);padding:6px">
      <rect x="2" y="2" width="20" height="20" rx="4" fill="#0f1724"/>
      <path d="M8 8h8v2H8zM8 12h8v2H8z" fill="#7c3aed"/>
    </svg>
    <div>
      <h1>Robô BackBook — Assistente (Graciano)</h1>
      <div class="subtitle">Robô local, algoritmo híbrido: frequência, recência, Markov e ruído — gera sinais e explica a decisão</div>
    </div>
  </header>

  <div class="grid" style="margin-top:16px">
    <!-- Left: controls + history -->
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="small">Entradas (últimas rodadas — mais recentes à esquerda)</div>
          <div class="small" style="margin-top:6px">Formato: B (Banca) / J (Jogador) / E (Empate). Separar por vírgula ou espaço.</div>
        </div>
        <div class="small">Versão: 1.0</div>
      </div>

      <div style="margin-top:10px">
        <textarea id="inputRounds" class="input" placeholder="Ex: J B B J E J B J B J E B J B J"></textarea>
        <div class="controls" style="margin-top:8px">
          <button id="btnParse" class="btn">Atualizar Robô (Parse)</button>
          <button id="btnSim10" class="btn ghost">Simular 10 rodadas</button>
          <button id="btnClear" class="btn ghost">Limpar</button>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0"/>

      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="small">Auto-observar</div>
          <div class="small">O robô gera sinal automaticamente quando novas rodadas entram.</div>
        </div>
        <div>
          <label class="small"><input id="autoObserve" type="checkbox"> Ativo</label>
        </div>
      </div>

      <div style="margin-top:12px">
        <div style="display:flex;gap:8px;align-items:center">
          <div class="small">Janela (N últimas):</div>
          <input id="windowN" type="number" value="15" min="3" max="50" style="width:80px;padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:inherit">
          <div class="small">Ruído aleatório:</div>
          <input id="noise" type="range" min="0" max="30" value="10">
          <div class="small" id="noiseVal">10%</div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div class="small">Pesos do algoritmo (ajusta o comportamento):</div>
        <div class="clusters" style="margin-top:8px">
          <div class="badge small">Markov <input id="wMarkov" type="range" min="0" max="100" value="40" style="vertical-align:middle"></div>
          <div class="badge small">Frequência <input id="wFreq" type="range" min="0" max="100" value="30" style="vertical-align:middle"></div>
          <div class="badge small">Recência <input id="wRec" type="range" min="0" max="100" value="20" style="vertical-align:middle"></div>
          <div class="badge small">Ruído <input id="wNoise" type="range" min="0" max="100" value="10" style="vertical-align:middle"></div>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0"/>

      <div>
        <div class="small">Histórico completo (lado esquerdo = mais recente)</div>
        <div id="historyBox" class="history" style="margin-top:8px"></div>
      </div>
    </div>

    <!-- Right: signal and probabilities -->
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="small">Sinal atual</div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
            <div id="pill" class="sinal-pill banca"><div class="dot" style="background:#fff;opacity:0.08;width:6px;height:18px;border-radius:4px"></div><span id="signalText">—</span></div>
            <div style="text-align:left">
              <div class="sinal-detail" id="explainText">O robô aguarda os dados.</div>
              <div class="small" style="margin-top:6px" id="confText">Confiança: —%</div>
            </div>
          </div>
        </div>
        <div style="text-align:center">
          <div class="small">Olá, <strong>Graciano</strong></div>
          <div style="margin-top:10px">
            <button id="btnGen" class="btn">Gerar Sinal Agora</button>
          </div>
        </div>
      </div>

      <div style="margin-top:16px">
        <div class="small">Probabilidades combinadas</div>
        <div class="prob-row">
          <div id="probB" class="prob-card banca"><div class="small">Banca</div><div class="big-prob" id="pB">0%</div></div>
          <div id="probJ" class="prob-card jogador"><div class="small">Jogador</div><div class="big-prob" id="pJ">0%</div></div>
          <div id="probE" class="prob-card empate"><div class="small">Empate</div><div class="big-prob" id="pE">0%</div></div>
        </div>
      </div>

      <div style="margin-top:12px;display:flex;justify-content:center;gap:8px;align-items:center">
        <button id="btnMute" class="btn ghost">Ativar Notificação</button>
        <button id="btnExport" class="btn ghost">Exportar Histórico</button>
      </div>

      <div style="margin-top:12px">
        <div class="small">Registro de decisões (últimas):</div>
        <div id="decisionLog" class="history" style="margin-top:8px"></div>
      </div>

    </div>
  </div>

  <footer class="card" style="margin-top:14px">
    <div class="small">Disclaimer: Este robô é uma **simulação local** para treino e análise. Não garante vitória em jogos reais. Usa com responsabilidade.</div>
  </footer>
</div>

<script>
/* ========= Robô BackBook — single-file implementation =========
   - Entrada: lista de rodadas (B/J/E), mais recentes à esquerda
   - Modelos: Markov 1-step + frequência + recência/momentum + ruído
   - Combinação: pesos ajustáveis (interface)
   - Outputs: probabilidades normalizadas + sinal com explicação + notificações
   - Autor: ChatGPT (gerado para Graciano), estrutura e lógica ensinada
   ============================================================= */

const el = (id)=>document.getElementById(id);
const inputRounds = el('inputRounds');
const btnParse = el('btnParse'), btnGen = el('btnGen'), btnSim10 = el('btnSim10'), btnClear = el('btnClear');
const historyBox = el('historyBox'), windowN = el('windowN'), noise = el('noise'), noiseVal = el('noiseVal');
const btnAuto = el('autoObserve'), wMarkov = el('wMarkov'), wFreq = el('wFreq'), wRec = el('wRec'), wNoise = el('wNoise');
const pill = el('pill'), signalText = el('signalText'), explainText = el('explainText'), confText = el('confText');
const pB = el('pB'), pJ = el('pJ'), pE = el('pE'), probB = el('probB'), probJ = el('probJ'), probE = el('probE');
const btnMute = el('btnMute'), btnExport = el('btnExport'), decisionLog = el('decisionLog'), btnClearHist = el('btnClear');

let rounds = [];   // array of 'B','J','E' newest first
let decisionHistory = []; // record decisions
let autoObserve = false;
let notifAllowed = false;

// helper
function normalize(obj){
  const sum = Object.values(obj).reduce((a,b)=>a+b,0) || 1;
  const out = {};
  for(const k in obj) out[k] = Math.max(0, obj[k]) / sum;
  return out;
}
function formatPct(x){ return Math.round(x*100) + '%'; }
function now(){ return new Date().toLocaleTimeString(); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

// parse input text to rounds array
function parseRoundsText(txt){
  if(!txt) return [];
  const parts = txt.trim().toUpperCase().split(/[\s,;]+/).filter(Boolean);
  const clean = parts.map(p=>{
    if(p.startsWith('B')) return 'B';
    if(p.startsWith('J')) return 'J';
    if(p.startsWith('E')) return 'E';
    return null;
  }).filter(Boolean);
  return clean;
}

// render history UI
function renderHistory(){
  historyBox.innerHTML = '';
  if(rounds.length===0){ historyBox.innerHTML = '<div class="small muted">Sem dados.</div>'; return; }
  rounds.forEach((r,i)=>{
    const div = document.createElement('div'); div.className='hist-item';
    div.innerHTML = `<div>#${i+1}</div><div style="display:flex;gap:8px;align-items:center"><div style="width:10px;height:10px;border-radius:2px;background:${r==='B'?'#e74c3c':r==='J'?'#3498db':'#2ecc71'}"></div><div>${r}</div></div>`;
    historyBox.appendChild(div);
  });
}

// export history as text
btnExport.addEventListener('click', ()=> {
  const blob = new Blob([rounds.join(', ')], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'history.txt'; a.click(); URL.revokeObjectURL(url);
});

// notification permission
async function requestNotif(){
  if(!('Notification' in window)) return alert('Notificações não suportadas neste navegador.');
  const perm = await Notification.requestPermission();
  notifAllowed = (perm === 'granted');
  btnMute.textContent = notifAllowed ? 'Notificações: ON' : 'Ativar Notificação';
}
btnMute.addEventListener('click', requestNotif);

// simulation helpers
btnSim10.addEventListener('click', ()=> {
  for(let i=0;i<10;i++) rounds.unshift(randChoice(['B','J','E']));
  rounds = rounds.slice(0,200);
  inputRounds.value = rounds.join(' ');
  renderHistory();
  if(btnAuto.checked) runRobot();
});
btnClear.addEventListener('click', ()=>{ rounds=[]; inputRounds.value=''; renderHistory(); });

// parse button
btnParse.addEventListener('click', ()=> {
  const parsed = parseRoundsText(inputRounds.value);
  if(parsed.length===0) return alert('Insere pelo menos 1 resultado (B/J/E).');
  rounds = parsed.slice(0,200);
  renderHistory();
  if(btnAuto.checked) runRobot();
});

// Markov model (1-step transitions)
function buildMarkov(arr){
  // arr: newest first, but for transition, we consider chronological: oldest -> newest
  const seq = [...arr].reverse(); // now oldest first
  const trans = {'B':{'B':0,'J':0,'E':0}, 'J':{'B':0,'J':0,'E':0}, 'E':{'B':0,'J':0,'E':0}};
  for(let i=0;i<seq.length-1;i++){
    const a = seq[i], b = seq[i+1];
    if(a && b) trans[a][b] += 1;
  }
  // normalize per row
  const probs = {'B':{},'J':{},'E':{}};
  for(const k of ['B','J','E']){
    const rowSum = Object.values(trans[k]).reduce((a,b)=>a+b,0) || 1;
    for(const j of ['B','J','E']) probs[k][j] = trans[k][j] / rowSum;
  }
  return probs;
}

// recency / momentum: weight recent results more heavily
function recencyScores(arr, window){
  // arr newest first, weight exponential for recency
  const w = window || arr.length;
  const scores = {B:0,J:0,E:0};
  for(let i=0;i<Math.min(w,arr.length);i++){
    const item = arr[i];
    const weight = Math.pow(0.85, i); // recent items have higher weight
    if(item) scores[item] += weight;
  }
  return normalize(scores);
}

// frequency baseline
function freqScores(arr, window){
  const counts = {B:0,J:0,E:0};
  const w = window || arr.length;
  for(let i=0;i<Math.min(w,arr.length);i++){
    const item = arr[i];
    if(item) counts[item] += 1;
  }
  return normalize(counts);
}

// transition forecast: given last result, predict next using Markov
function markovForecast(markovModel, last){
  if(!last) return {'B':1/3,'J':1/3,'E':1/3};
  return markovModel[last] ? {...markovModel[last]} : {'B':1/3,'J':1/3,'E':1/3};
}

// combine models
function combineModels(opts){
  // opts: {wMarkov,wFreq,wRec,wNoise, noisePercent}
  const wM = opts.wMarkov, wF = opts.wFreq, wR = opts.wRec, wN = opts.wNoise;
  const window = parseInt(windowN.value) || 15;
  const recent = recencyScores(rounds, window);
  const freq = freqScores(rounds, window);
  const markov = buildMarkov(rounds);
  const last = rounds[0] || null;
  const markovPred = markovForecast(markov, last);
  // noise
  const noisePct = parseInt(noise.value) / 100.0;
  const noiseVec = {'B':Math.random(), 'J':Math.random(), 'E':Math.random()};
  const normNoise = normalize(noiseVec);

  // weighted sum
  let combined = {'B':0,'J':0,'E':0};
  for(const k of ['B','J','E']){
    combined[k] = (wM * markovPred[k]) + (wF * freq[k]) + (wR * recent[k]) + (wN * normNoise[k]);
  }
  // apply external noisePct: blend with random to avoid determinism
  const rnd = normalize({'B':Math.random(),'J':Math.random(),'E':Math.random()});
  for(const k of ['B','J','E']){
    combined[k] = (1 - noisePct) * combined[k] + noisePct * rnd[k];
  }
  // normalize and return
  const norm = normalize(combined);
  return {prob: norm, explanation:{markovPred, freq, recent, noisePct}};
}

// pretty explanation builder
function buildExplanation(models){
  const last = rounds[0] || 'N/A';
  const parts = [];
  if(rounds.length===0) return "Sem dados suficientes — insere rodadas ou usa simulação.";
  parts.push(`Último resultado: ${last}`);
  const topBy = Object.entries(models.prob).sort((a,b)=>b[1]-a[1]);
  const [topKey, topVal] = topBy[0];
  // decode
  const decode = k => (k==='B'?'Banca':k==='J'?'Jogador':'Empate');
  parts.push(`Com base em Markov, frequência e recência, a maior probabilidade é para ${decode(topKey)} (${formatPct(topVal)})`);
  parts.push(`Janela: ${windowN.value} / Ruído: ${Math.round(models.explanation.noisePct*100)}%`);
  // include short stats
  const freq = models.explanation.freq;
  parts.push(`Frequências (janela): B ${formatPct(freq.B)}, J ${formatPct(freq.J)}, E ${formatPct(freq.E)}`);
  return parts.join(' • ');
}

// render probabilities and UI
function renderProbs(probObj){
  pB.textContent = formatPct(probObj.B);
  pJ.textContent = formatPct(probObj.J);
  pE.textContent = formatPct(probObj.E);
  // highlight pill and style
  const top = Object.entries(probObj).sort((a,b)=>b[1]-a[1])[0][0];
  const pct = Math.round(Object.entries(probObj).sort((a,b)=>b[1]-a[1])[0][1]*100);
  signalText.textContent = top==='B'?'Banca':top==='J'?'Jogador':'Empate';
  confText.textContent = 'Confiança: ' + pct + '%';
  // pill class
  pill.className = 'sinal-pill ' + (top==='B'?'banca':top==='J'?'jogador':'empate') + ' pulse';
  explainText.textContent = currentExplanation || '';
  // update color cards shadow
  probB.style.opacity = 1; probJ.style.opacity = 1; probE.style.opacity = 1;
}

// decision log
function pushDecision(decision){
  decisionHistory.unshift(decision);
  if(decisionHistory.length>50) decisionHistory.pop();
  decisionLog.innerHTML = decisionHistory.map(d=>{
    return `<div class="hist-item"><div>${d.time}</div><div style="display:flex;gap:8px;align-items:center"><div style="width:10px;height:10px;border-radius:2px;background:${d.choice==='Banca'?'#e74c3c':d.choice==='Jogador'?'#3498db':'#2ecc71'}"></div><div><strong>${d.choice}</strong> <div class="muted" style="font-size:0.85rem">${d.reason}</div></div></div></div>`;
  }).join('');
}

// run robot once (generate signal now)
let currentExplanation = '';
function runRobot(){
  // read weights
  const totalW = (parseInt(wMarkov.value)||0) + (parseInt(wFreq.value)||0) + (parseInt(wRec.value)||0) + (parseInt(wNoise.value)||0);
  // normalize weights to percentages
  const opts = {
    wMarkov: (parseInt(wMarkov.value)||0) / Math.max(totalW,1),
    wFreq: (parseInt(wFreq.value)||0) / Math.max(totalW,1),
    wRec: (parseInt(wRec.value)||0) / Math.max(totalW,1),
    wNoise: (parseInt(wNoise.value)||0) / Math.max(totalW,1)
  };
  // combine models but we want to use weight scale 0-1, so scale accordingly
  const scaled = { wMarkov: opts.wMarkov, wFreq: opts.wFreq, wRec: opts.wRec, wNoise: opts.wNoise };
  // compute with internal implementation expecting relative weights; we'll map 0-1 to 0-100
  const compute = combineModels({ wMarkov: scaled.wMarkov*100, wFreq: scaled.wFreq*100, wRec: scaled.wRec*100, wNoise: scaled.wNoise*100 });
  currentExplanation = buildExplanation(compute);
  renderProbs(compute.prob);
  // log the decision
  const top = Object.entries(compute.prob).sort((a,b)=>b[1]-a[1])[0][0];
  const choice = top==='B'?'Banca':top==='J'?'Jogador':'Empate';
  const reason = currentExplanation;
  pushDecision({time: now(), choice, reason});
  // show browser notification optionally
  if(notifAllowed){
    try{
      const n = new Notification(`Olá Graciano — Sinal: ${choice}`, {body: reason, icon: null});
    }catch(e){}
  } else {
    // subtle sound feedback
    try{
      const audio = new Audio('data:audio/ogg;base64,T2dnUwACAAAAAAAAAABVDwAAAAAA...'); // small placeholder, omitted big base64
      // audio.play(); // commented to avoid autoplay issues on some devices
    }catch(e){}
  }
}

// when auto-observe is on, runRobot when new rounds added
btnAuto.addEventListener('change', ()=>{ /* handled outside */ });

// UI wiring
btnGen.addEventListener('click', ()=> {
  if(rounds.length===0) {
    if(!confirm('Sem dados — queres gerar 15 rodadas simuladas como ponto de partida?')) return;
    for(let i=0;i<15;i++) rounds.unshift(randChoice(['B','J','E']));
    inputRounds.value = rounds.join(' ');
    renderHistory();
  }
  runRobot();
});

// auto-observe: when input changes and checkbox active, parse and run
inputRounds.addEventListener('input', ()=> {
  const parsed = parseRoundsText(inputRounds.value);
  if(parsed.length>0) rounds = parsed;
  renderHistory();
  if(btnAuto.checked) runRobot();
});

// windowN and noise UI
noise.addEventListener('input', ()=> noiseVal.textContent = noise.value + '%');

// initial state
(function init(){
  // default sample
  rounds = ['J','B','B','J','E','J','B','J','B','J','E','B','J','B','J'];
  inputRounds.value = rounds.join(' ');
  renderHistory();
  // initial probabilities render
  runRobot();
})();

// export/import: Allow drop in of new data via paste (already using textarea)
// When rounds array is updated and autoObserve is checked, run robot automatically
const origPush = Array.prototype.unshift;
function observePush(){
  if(btnAuto.checked) runRobot();
}
inputRounds.addEventListener('change', ()=>{ if(btnAuto.checked) runRobot(); });

// allow clearing logs
btnClearHist.addEventListener('click', ()=>{ decisionHistory=[]; decisionLog.innerHTML=''; });

// small UX: click on a history item to remove (optional)
historyBox.addEventListener('click', (ev)=>{
  const idx = Array.from(historyBox.children).indexOf(ev.target.closest('.hist-item'));
  if(idx>=0){
    if(confirm('Remover esta rodada do histórico?')){ rounds.splice(idx,1); inputRounds.value = rounds.join(' '); renderHistory(); if(btnAuto.checked) runRobot(); }<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Robô BackBook - Graciano</title>
<style>
  /* ========== Estilo Geral ========== */
  :root{
    --bg:#071025;
    --card:#0b1225;
    --accent:#7c3aed;
    --banca:#e74c3c;
    --jogador:#3498db;
    --empate:#2ecc71;
    --glass: rgba(255,255,255,0.05);
    --text:#e6eef6;
    --muted:#94a3b8;
  }
  *{box-sizing:border-box;margin:0;padding:0;font-family:Arial,sans-serif;}
  body{background:var(--bg);color:var(--text);line-height:1.4;}
  .wrap{max-width:960px;margin:20px auto;padding:16px;}
  h1,h2,h3{margin-bottom:8px;}
  h1{font-size:1.5rem;}
  .subtitle{color:var(--muted);font-size:0.9rem;}
  .card{background:var(--card);border-radius:12px;padding:16px;margin-bottom:16px;box-shadow:0 8px 20px rgba(0,0,0,0.5);}
  button{padding:10px 14px;border:none;border-radius:8px;background:var(--accent);color:#fff;font-weight:bold;cursor:pointer;transition:0.2s;}
  button:hover{opacity:0.85;}
  input, textarea{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:transparent;color:#fff;margin-top:6px;}
  textarea{resize:vertical;}
  .flex{display:flex;gap:12px;align-items:center;}
  .flex-col{display:flex;flex-direction:column;}
  .space-between{justify-content:space-between;}
  .history{max-height:200px;overflow-y:auto;margin-top:10px;border:1px solid rgba(255,255,255,0.1);border-radius:8px;padding:8px;background:var(--glass);}
  .hist-item{display:flex;justify-content:space-between;padding:6px;border-bottom:1px dashed rgba(255,255,255,0.1);}
  .sinal{padding:12px;border-radius:10px;text-align:center;margin-top:10px;font-size:1.2rem;font-weight:bold;}
  .banca{background:var(--banca);}
  .jogador{background:var(--jogador);}
  .empate{background:var(--empate);}
  .prob-row{display:flex;gap:8px;margin-top:12px;}
  .prob-card{flex:1;padding:10px;border-radius:8px;text-align:center;background:var(--glass);}
  .small{font-size:0.85rem;color:var(--muted);}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.2);}
  footer{text-align:center;font-size:0.8rem;color:var(--muted);margin-top:16px;}
  @media(max-width:600px){.flex{flex-direction:column;}}
</style>
</head>
<body>
<div class="wrap">
  <h1>Robô BackBook - Graciano</h1>
  <div class="subtitle">Assistente Bac Bo simulado em tempo real, sinais probabilísticos com histórico</div>

  <!-- Entrada de rodadas -->
  <div class="card">
    <h2>Entradas (Últimas 15 rodadas)</h2>
    <div class="small">Use B = Banca, J = Jogador, E = Empate (separados por espaço ou vírgula)</div>
    <textarea id="inputRounds" placeholder="Ex: J B B J E J B J B J E B J B J"></textarea>
    <div class="flex" style="margin-top:8px;">
      <button id="btnParse">Atualizar Robô</button>
      <button id="btnSim10" class="btn-ghost">Simular 10 rodadas</button>
      <button id="btnClear" class="btn-ghost">Limpar</button>
    </div>
    <div class="history" id="historyBox"></div>
  </div>

  <!-- Sinal do robô -->
  <div class="card">
    <h2>Sinal Atual</h2>
    <div class="sinal banca" id="signalText">—</div>
    <div class="small" id="explainText">O robô aguarda os dados...</div>
    <div class="flex" style="margin-top:8px;">
      <button id="btnGen">Gerar Sinal Agora</button>
      <button id="btnNotif" class="btn-ghost">Ativar Notificação</button>
    </div>
    <div class="prob-row">
      <div class="prob-card banca">
        <div class="small">Banca</div>
        <div id="pB">0%</div>
      </div>
      <div class="prob-card jogador">
        <div class="small">Jogador</div>
        <div id="pJ">0%</div>
      </div>
      <div class="prob-card empate">
        <div class="small">Empate</div>
        <div id="pE">0%</div>
      </div>
    </div>
  </div>

  <!-- Histórico de decisões -->
  <div class="card">
    <h2>Histórico de Decisões</h2>
    <div class="history" id="decisionLog"></div>
  </div>

  <footer>
    Disclaimer: Este robô é apenas uma simulação de treino. Não garante ganhos reais em casino.
  </footer>
</div>

<script>
// ========= Robô BackBook =========
const inputRounds = document.getElementById('inputRounds');
const btnParse = document.getElementById('btnParse');
const btnGen = document.getElementById('btnGen');
const btnSim10 = document.getElementById('btnSim10');
const btnClear = document.getElementById('btnClear');
const historyBox = document.getElementById('historyBox');
const signalText = document.getElementById('signalText');
const explainText = document.getElementById('explainText');
const pB = document.getElementById('pB');
const pJ = document.getElementById('pJ');
const pE = document.getElementById('pE');
const decisionLog = document.getElementById('decisionLog');
const btnNotif = document.getElementById('btnNotif');

let rounds = [];
let decisionHistory = [];
let notifAllowed = false;

// Normalizar probabilidades
function normalize(obj){
  const sum = Object.values(obj).reduce((a,b)=>a+b,0)||1;
  const out = {};
  for(const k in obj) out[k]=obj[k]/sum;
  return out;
}

// Formatar %
function fmtPct(x){ return Math.round(x*100)+'%';}

// Parse rounds
function parseRounds(txt){
  const parts = txt.trim().toUpperCase().split(/[\s,]+/).filter(Boolean);
  return parts.map(p=>{
    if(p.startsWith('B')) return 'B';
    if(p.startsWith('J')) return 'J';
    if(p.startsWith('E')) return 'E';
    return null;
  }).filter(Boolean);
}

// Render history
function renderHistory(){
  historyBox.innerHTML='';
  rounds.forEach((r,i)=>{
    const div = document.createElement('div');
    div.className='hist-item';
    div.innerHTML=`<div>#${i+1}</div><div>${r}</div>`;
    historyBox.appendChild(div);
  });
}

// Probabilidades simples: frequência + ruído
function calcProb(){
  const count = {B:0,J:0,E:0};
  rounds.forEach(r=>{count[r]++;});
  // adicionar ruído leve
  const noise = Math.random()*0.1;
  const prob = {B:count.B+noise, J:count.J+noise, E:count.E+noise};
  return normalize(prob);
}

// Gerar sinal
function generateSignal(){
  if(rounds.length===0) return alert('Insira rodadas antes!');
  const prob = calcProb();
  // atualiza UI probabilidades
  pB.textContent = fmtPct(prob.B);
  pJ.textContent = fmtPct(prob.J);
  pE.textContent = fmtPct(prob.E);
  // sinal principal
  const top = Object.entries(prob).sort((a,b)=>b[1]-a[1])[0][0];
  const choice = top==='B'?'Banca':top==='J'?'Jogador':'Empate';
  signalText.textContent = choice;
  signalText.className='sinal '+top.toLowerCase();
  explainText.textContent=`Probabilidade maior para ${choice} — baseada nas últimas rodadas.`;
  // log decisão
  decisionHistory.unshift({time:new Date().toLocaleTimeString(), choice, reason:explainText.textContent});
  if(decisionHistory.length>50) decisionHistory.pop();
  decisionLog.innerHTML = decisionHistory.map(d=>`<div class="hist-item"><div>${d.time}</div><div>${d.choice}</div></div>`).join('');
  // notificação
  if(notifAllowed) new Notification(`Sinal: ${choice}`,{body:explainText.textContent});
}

// botões
btnParse.onclick = ()=>{
  rounds = parseRounds(inputRounds.value);
  renderHistory();
};
btnGen.onclick = ()=>generateSignal();
btnSim10.onclick = ()=>{
  for(let i=0;i<10;i++) rounds.unshift(['B','J','E'][Math.floor(Math.random()*3)]);
  inputRounds.value = rounds.join(' ');
  renderHistory();
};
btnClear.onclick = ()=>{
  rounds=[]; inputRounds.value=''; renderHistory();
  signalText.textContent='—'; explainText.textContent='O robô aguarda os dados...';
  decisionLog.innerHTML=''; decisionHistory=[];
};
btnNotif.onclick = async ()=>{
  if(!('Notification' in window)) return alert('Navegador não suporta notificações');
  const perm = await Notification.requestPermission();
  notifAllowed = perm==='granted';
  btnNotif.textContent = notifAllowed?'Notificação ON':'Ativar Notificação';
};

// Inicial
rounds = ['J','B','B','J','E','J','B','J','B','J','E','B','J','B','J'];
inputRounds.value = rounds.join(' ');
renderHistory();
generateSignal();
</script>
</body>
</html>
  }
});

</script>
</body>
</html>
